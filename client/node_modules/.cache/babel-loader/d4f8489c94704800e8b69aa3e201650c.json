{"ast":null,"code":"import _createForOfIteratorHelper from \"C:/Users/37529/react-apps/health-app/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/createForOfIteratorHelper\";\n\n/* eslint-disable camelcase */\nimport chart_color_black_500 from \"@patternfly/react-tokens/dist/esm/chart_color_black_500\";\nimport { Helpers } from 'victory-core';\nimport { ChartLegendTooltipStyles } from '../ChartTheme';\nimport { getLegendDimensions } from './chart-legend';\n/**\n * When using a cursor container, the tooltip can be offset from the cursor point. If offsetCursorDimensionX is true,\n * the tooltip will appear to the right the vertical cursor. If offsetCursorDimensionY is true, the tooltip will appear\n * above the vertical cursor.\n */\n\nexport var getCursorTooltipCenterOffset = function getCursorTooltipCenterOffset(_ref) {\n  var _ref$offsetCursorDime = _ref.offsetCursorDimensionX,\n      offsetCursorDimensionX = _ref$offsetCursorDime === void 0 ? false : _ref$offsetCursorDime,\n      _ref$offsetCursorDime2 = _ref.offsetCursorDimensionY,\n      offsetCursorDimensionY = _ref$offsetCursorDime2 === void 0 ? false : _ref$offsetCursorDime2,\n      theme = _ref.theme;\n  var pointerLength = theme && theme.tooltip ? Helpers.evaluateProp(theme.tooltip.pointerLength) : 10;\n\n  var offsetX = function offsetX(_ref2) {\n    var center = _ref2.center,\n        flyoutWidth = _ref2.flyoutWidth,\n        width = _ref2.width;\n    var offset = flyoutWidth / 2 + pointerLength;\n    return width > center.x + flyoutWidth + pointerLength ? offset : -offset;\n  };\n\n  var offsetY = function offsetY(_ref3) {\n    var center = _ref3.center,\n        flyoutHeight = _ref3.flyoutHeight,\n        width = _ref3.width;\n    var offset = flyoutHeight / 2 + pointerLength;\n    return width > center.y + flyoutHeight + pointerLength ? -offset : offset;\n  };\n\n  return {\n    x: offsetCursorDimensionX ? offsetX : 0,\n    y: offsetCursorDimensionY ? offsetY : 0\n  };\n};\n/**\n * When using a cursor container, the tooltip pointer orientation can be adjusted as the cursor approaches the edge of\n * the chart. If horizontal is true, the tooltip pointer will either be 'left' or 'right'. If horizontal is true, the\n * tooltip pointer will either be 'top' or 'bottom'.\n */\n\nexport var getCursorTooltipPoniterOrientation = function getCursorTooltipPoniterOrientation(_ref4) {\n  var _ref4$horizontal = _ref4.horizontal,\n      horizontal = _ref4$horizontal === void 0 ? true : _ref4$horizontal,\n      theme = _ref4.theme;\n  var pointerLength = theme && theme.tooltip ? Helpers.evaluateProp(theme.tooltip.pointerLength) : 10;\n\n  var orientationX = function orientationX(_ref5) {\n    var center = _ref5.center,\n        flyoutWidth = _ref5.flyoutWidth,\n        width = _ref5.width;\n    return width > center.x + flyoutWidth + pointerLength ? 'left' : 'right';\n  };\n\n  var orientationY = function orientationY(_ref6) {\n    var center = _ref6.center,\n        flyoutHeight = _ref6.flyoutHeight,\n        height = _ref6.height;\n    return height > center.y + flyoutHeight + pointerLength ? 'top' : 'bottom';\n  };\n\n  return horizontal ? orientationX : orientationY;\n}; // Returns props associated with legend data\n\nexport var getLegendTooltipDataProps = function getLegendTooltipDataProps(defaultProps) {\n  return Object.assign({\n    borderPadding: 0,\n    gutter: 0,\n    orientation: 'vertical',\n    padding: 0,\n    rowGutter: 0,\n    style: {\n      labels: {\n        fill: ChartLegendTooltipStyles.label.fill,\n        lineHeight: 0.275,\n        padding: 0\n      },\n      title: {\n        fill: ChartLegendTooltipStyles.label.fill,\n        padding: 0\n      }\n    }\n  }, defaultProps);\n}; // Returns the legend height and width\n\nexport var getLegendTooltipSize = function getLegendTooltipSize(_ref7) {\n  var legendData = _ref7.legendData,\n      _ref7$legendOrientati = _ref7.legendOrientation,\n      legendOrientation = _ref7$legendOrientati === void 0 ? 'vertical' : _ref7$legendOrientati,\n      legendProps = _ref7.legendProps,\n      _ref7$text = _ref7.text,\n      text = _ref7$text === void 0 ? '' : _ref7$text,\n      theme = _ref7.theme;\n  var textEvaluated = Helpers.evaluateProp(text);\n\n  var _text = Array.isArray(textEvaluated) ? textEvaluated : [textEvaluated]; // Find max char lengths\n\n\n  var maxDataLength = 0;\n  var maxTextLength = 0;\n\n  _text.map(function (name, index) {\n    if (name) {\n      if (name.length > maxTextLength) {\n        maxTextLength = name.length;\n      }\n\n      var hasData = legendData && legendData[index] && legendData[index].name;\n\n      if (hasData) {\n        if (legendData[index].name.length > maxDataLength) {\n          maxDataLength = legendData[index].name.length;\n        }\n      }\n    }\n  }); // Set length to ensure minimum spacing between label and value\n\n\n  var maxLength = maxDataLength + maxTextLength;\n\n  if (maxDataLength < 20) {\n    maxLength += 2;\n  } // Get spacing to help align legend labels and text values\n\n\n  var spacer = 'x';\n\n  var getSpacing = function getSpacing(legendLabel, textLabel) {\n    var spacing = '';\n\n    if (maxLength === 0) {\n      return spacing;\n    }\n\n    var legendLabelChars = legendLabel ? legendLabel.length : 0;\n    var textLabelChars = textLabel ? textLabel.length : 0;\n    var maxChars = legendLabelChars + textLabelChars; // Add spacer\n\n    while (spacing.length < maxLength - maxChars) {\n      spacing += spacer;\n    }\n\n    return spacing;\n  }; // Format all text (similar to below) to help determine overall width.\n  //\n  // {name: \"Cats   no data\"}\n  // {name: \"Dogs         1\"}\n  // {name: \"Birds        4\"}\n  // {name: \"Mice         3\"}\n\n\n  var data = _text.map(function (label, index) {\n    var hasData = legendData && legendData[index] && legendData[index].name;\n    var spacing = hasData ? getSpacing(legendData[index].name, label) : '';\n    return {\n      name: \"\".concat(hasData ? legendData[index].name : '').concat(spacing).concat(label)\n    };\n  }); // Replace whitespace with spacer char for consistency in width\n\n\n  var formattedData = data.map(function (val) {\n    return {\n      name: val.name.replace(/ /g, spacer)\n    };\n  }); // This should include both legend data and text\n\n  var widthDimensions = getLegendDimensions({\n    legendData: formattedData,\n    legendOrientation: legendOrientation,\n    legendProps: legendProps,\n    theme: theme\n  }); // This should only use text. The row gutter changes when displaying all \"no data\" messages\n\n  var heightDimensions = getLegendDimensions({\n    legendData: _text.map(function (name) {\n      return {\n        name: name\n      };\n    }),\n    legendOrientation: legendOrientation,\n    legendProps: legendProps,\n    theme: theme\n  });\n  return {\n    height: heightDimensions.height,\n    width: widthDimensions.width > 0 ? widthDimensions.width : 0\n  };\n}; // Returns visible legend data, while syncing color scale. If textAsLegendData is true, the text prop is used as\n// legend data so y values can be passed individually to the label component\n\nexport var getLegendTooltipVisibleData = function getLegendTooltipVisibleData(_ref8) {\n  var activePoints = _ref8.activePoints,\n      colorScale = _ref8.colorScale,\n      legendData = _ref8.legendData,\n      text = _ref8.text,\n      _ref8$textAsLegendDat = _ref8.textAsLegendData,\n      textAsLegendData = _ref8$textAsLegendDat === void 0 ? false : _ref8$textAsLegendDat,\n      theme = _ref8.theme;\n  var textEvaluated = Helpers.evaluateProp(text);\n\n  var _text = Array.isArray(textEvaluated) ? textEvaluated : [textEvaluated];\n\n  var result = []; // Sync data with interactive legends\n\n  if (legendData) {\n    var index = -1;\n\n    var _loop = function _loop(i) {\n      var data = legendData[i];\n      var activePoint = activePoints ? activePoints.find(function (item) {\n        return item.childName === data.childName;\n      }) : '';\n\n      if (!activePoint || data.symbol && data.symbol.type === 'eyeSlash' && data.symbol.fill === chart_color_black_500.value) {\n        return \"continue\"; // Skip hidden data\n      }\n\n      if (index++ < _text.length - 1) {\n        var themeColor = theme && theme.legend && theme.legend.colorScale ? theme.legend.colorScale[i % theme.legend.colorScale.length] : undefined;\n        result.push({\n          name: textAsLegendData ? _text[index] : data.name,\n          symbol: Object.assign({\n            fill: colorScale ? colorScale[i % colorScale.length] : themeColor\n          }, data.symbol)\n        });\n      }\n    };\n\n    for (var i = 0; i < legendData.length; i++) {\n      var _ret = _loop(i);\n\n      if (_ret === \"continue\") continue;\n    }\n  }\n\n  return result;\n}; // Returns visible text for interactive legends\n\nexport var getLegendTooltipVisibleText = function getLegendTooltipVisibleText(_ref9) {\n  var activePoints = _ref9.activePoints,\n      legendData = _ref9.legendData,\n      text = _ref9.text;\n  var textEvaluated = Helpers.evaluateProp(text);\n\n  var _text = Array.isArray(textEvaluated) ? textEvaluated : [textEvaluated];\n\n  var result = [];\n\n  if (legendData) {\n    var index = -1;\n\n    var _iterator = _createForOfIteratorHelper(legendData),\n        _step;\n\n    try {\n      var _loop2 = function _loop2() {\n        var data = _step.value;\n        var activePoint = activePoints ? activePoints.find(function (item) {\n          return item.childName === data.childName;\n        }) : '';\n\n        if (!activePoint || data.symbol && data.symbol.type === 'eyeSlash' && data.symbol.fill === chart_color_black_500.value) {\n          return \"continue\"; // Skip hidden data\n        }\n\n        if (index++ < _text.length - 1) {\n          result.push(_text[index]);\n        }\n      };\n\n      for (_iterator.s(); !(_step = _iterator.n()).done;) {\n        var _ret2 = _loop2();\n\n        if (_ret2 === \"continue\") continue;\n      }\n    } catch (err) {\n      _iterator.e(err);\n    } finally {\n      _iterator.f();\n    }\n  }\n\n  return result;\n};","map":{"version":3,"sources":["../../../../src/components/ChartUtils/chart-tooltip.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["/* eslint-disable camelcase */\nimport chart_color_black_500 from \"@patternfly/react-tokens/dist/esm/chart_color_black_500\";\nimport { Helpers } from 'victory-core';\nimport { ChartLegendTooltipStyles } from '../ChartTheme';\nimport { getLegendDimensions } from './chart-legend';\n/**\n * When using a cursor container, the tooltip can be offset from the cursor point. If offsetCursorDimensionX is true,\n * the tooltip will appear to the right the vertical cursor. If offsetCursorDimensionY is true, the tooltip will appear\n * above the vertical cursor.\n */\nexport const getCursorTooltipCenterOffset = ({ offsetCursorDimensionX = false, offsetCursorDimensionY = false, theme }) => {\n    const pointerLength = theme && theme.tooltip ? Helpers.evaluateProp(theme.tooltip.pointerLength) : 10;\n    const offsetX = ({ center, flyoutWidth, width }) => {\n        const offset = flyoutWidth / 2 + pointerLength;\n        return width > center.x + flyoutWidth + pointerLength ? offset : -offset;\n    };\n    const offsetY = ({ center, flyoutHeight, width }) => {\n        const offset = flyoutHeight / 2 + pointerLength;\n        return width > center.y + flyoutHeight + pointerLength ? -offset : offset;\n    };\n    return {\n        x: offsetCursorDimensionX ? offsetX : 0,\n        y: offsetCursorDimensionY ? offsetY : 0\n    };\n};\n/**\n * When using a cursor container, the tooltip pointer orientation can be adjusted as the cursor approaches the edge of\n * the chart. If horizontal is true, the tooltip pointer will either be 'left' or 'right'. If horizontal is true, the\n * tooltip pointer will either be 'top' or 'bottom'.\n */\nexport const getCursorTooltipPoniterOrientation = ({ horizontal = true, theme }) => {\n    const pointerLength = theme && theme.tooltip ? Helpers.evaluateProp(theme.tooltip.pointerLength) : 10;\n    const orientationX = ({ center, flyoutWidth, width }) => width > center.x + flyoutWidth + pointerLength ? 'left' : 'right';\n    const orientationY = ({ center, flyoutHeight, height }) => height > center.y + flyoutHeight + pointerLength ? 'top' : 'bottom';\n    return horizontal ? orientationX : orientationY;\n};\n// Returns props associated with legend data\nexport const getLegendTooltipDataProps = (defaultProps) => (Object.assign({ borderPadding: 0, gutter: 0, orientation: 'vertical', padding: 0, rowGutter: 0, style: {\n        labels: {\n            fill: ChartLegendTooltipStyles.label.fill,\n            lineHeight: 0.275,\n            padding: 0\n        },\n        title: {\n            fill: ChartLegendTooltipStyles.label.fill,\n            padding: 0\n        }\n    } }, defaultProps));\n// Returns the legend height and width\nexport const getLegendTooltipSize = ({ legendData, legendOrientation = 'vertical', legendProps, text = '', theme }) => {\n    const textEvaluated = Helpers.evaluateProp(text);\n    const _text = Array.isArray(textEvaluated) ? textEvaluated : [textEvaluated];\n    // Find max char lengths\n    let maxDataLength = 0;\n    let maxTextLength = 0;\n    _text.map((name, index) => {\n        if (name) {\n            if (name.length > maxTextLength) {\n                maxTextLength = name.length;\n            }\n            const hasData = legendData && legendData[index] && legendData[index].name;\n            if (hasData) {\n                if (legendData[index].name.length > maxDataLength) {\n                    maxDataLength = legendData[index].name.length;\n                }\n            }\n        }\n    });\n    // Set length to ensure minimum spacing between label and value\n    let maxLength = maxDataLength + maxTextLength;\n    if (maxDataLength < 20) {\n        maxLength += 2;\n    }\n    // Get spacing to help align legend labels and text values\n    const spacer = 'x';\n    const getSpacing = (legendLabel, textLabel) => {\n        let spacing = '';\n        if (maxLength === 0) {\n            return spacing;\n        }\n        const legendLabelChars = legendLabel ? legendLabel.length : 0;\n        const textLabelChars = textLabel ? textLabel.length : 0;\n        const maxChars = legendLabelChars + textLabelChars;\n        // Add spacer\n        while (spacing.length < maxLength - maxChars) {\n            spacing += spacer;\n        }\n        return spacing;\n    };\n    // Format all text (similar to below) to help determine overall width.\n    //\n    // {name: \"Cats   no data\"}\n    // {name: \"Dogs         1\"}\n    // {name: \"Birds        4\"}\n    // {name: \"Mice         3\"}\n    const data = _text.map((label, index) => {\n        const hasData = legendData && legendData[index] && legendData[index].name;\n        const spacing = hasData ? getSpacing(legendData[index].name, label) : '';\n        return {\n            name: `${hasData ? legendData[index].name : ''}${spacing}${label}`\n        };\n    });\n    // Replace whitespace with spacer char for consistency in width\n    const formattedData = data.map(val => ({\n        name: val.name.replace(/ /g, spacer)\n    }));\n    // This should include both legend data and text\n    const widthDimensions = getLegendDimensions({\n        legendData: formattedData,\n        legendOrientation,\n        legendProps,\n        theme\n    });\n    // This should only use text. The row gutter changes when displaying all \"no data\" messages\n    const heightDimensions = getLegendDimensions({\n        legendData: _text.map((name) => ({ name })),\n        legendOrientation,\n        legendProps,\n        theme\n    });\n    return {\n        height: heightDimensions.height,\n        width: widthDimensions.width > 0 ? widthDimensions.width : 0\n    };\n};\n// Returns visible legend data, while syncing color scale. If textAsLegendData is true, the text prop is used as\n// legend data so y values can be passed individually to the label component\nexport const getLegendTooltipVisibleData = ({ activePoints, colorScale, legendData, text, textAsLegendData = false, theme }) => {\n    const textEvaluated = Helpers.evaluateProp(text);\n    const _text = Array.isArray(textEvaluated) ? textEvaluated : [textEvaluated];\n    const result = [];\n    // Sync data with interactive legends\n    if (legendData) {\n        let index = -1;\n        for (let i = 0; i < legendData.length; i++) {\n            const data = legendData[i];\n            const activePoint = activePoints ? activePoints.find(item => item.childName === data.childName) : '';\n            if (!activePoint ||\n                (data.symbol && data.symbol.type === 'eyeSlash' && data.symbol.fill === chart_color_black_500.value)) {\n                continue; // Skip hidden data\n            }\n            if (index++ < _text.length - 1) {\n                const themeColor = theme && theme.legend && theme.legend.colorScale\n                    ? theme.legend.colorScale[i % theme.legend.colorScale.length]\n                    : undefined;\n                result.push({\n                    name: textAsLegendData ? _text[index] : data.name,\n                    symbol: Object.assign({ fill: colorScale ? colorScale[i % colorScale.length] : themeColor }, data.symbol)\n                });\n            }\n        }\n    }\n    return result;\n};\n// Returns visible text for interactive legends\nexport const getLegendTooltipVisibleText = ({ activePoints, legendData, text }) => {\n    const textEvaluated = Helpers.evaluateProp(text);\n    const _text = Array.isArray(textEvaluated) ? textEvaluated : [textEvaluated];\n    const result = [];\n    if (legendData) {\n        let index = -1;\n        for (const data of legendData) {\n            const activePoint = activePoints ? activePoints.find(item => item.childName === data.childName) : '';\n            if (!activePoint ||\n                (data.symbol && data.symbol.type === 'eyeSlash' && data.symbol.fill === chart_color_black_500.value)) {\n                continue; // Skip hidden data\n            }\n            if (index++ < _text.length - 1) {\n                result.push(_text[index]);\n            }\n        }\n    }\n    return result;\n};\n//# sourceMappingURL=chart-tooltip.js.map"]},"metadata":{},"sourceType":"module"}