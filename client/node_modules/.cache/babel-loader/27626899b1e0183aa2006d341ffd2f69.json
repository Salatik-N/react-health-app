{"ast":null,"code":"import * as React from 'react';\nimport PropTypes from 'prop-types';\nimport { Helpers, CommonProps, Path } from 'victory-core';\nimport isPlainObject from 'lodash/isPlainObject';\n\nvar getVerticalPath = function getVerticalPath(props) {\n  var pointerWidth = props.pointerWidth,\n      cornerRadius = props.cornerRadius,\n      orientation = props.orientation,\n      width = props.width,\n      height = props.height,\n      center = props.center;\n  var sign = orientation === 'bottom' ? 1 : -1; // const x = props.x + (props.dx || 0);\n  // const y = props.y + (props.dy || 0);\n\n  var centerX = isPlainObject(center) && center.x;\n  var centerY = isPlainObject(center) && center.y;\n  var pointerEdge = centerY + sign * (height / 2);\n  var oppositeEdge = centerY - sign * (height / 2);\n  var rightEdge = centerX + width / 2;\n  var leftEdge = centerX - width / 2; // This has been overridden so the pointer does not stick to data points -- want pointerLength to take precedence\n\n  var x = center.x + (props.dx || 0);\n  var y = orientation === 'bottom' ? pointerEdge + props.pointerLength + (props.dy || 0) : pointerEdge - props.pointerLength + (props.dy || 0);\n  var pointerLength = sign * (y - pointerEdge) < 0 ? 0 : props.pointerLength;\n  var direction = orientation === 'bottom' ? '0 0 0' : '0 0 1';\n  var arc = \"\".concat(cornerRadius, \" \").concat(cornerRadius, \" \").concat(direction);\n  return \"M \".concat(centerX - pointerWidth / 2, \", \").concat(pointerEdge, \"\\n    L \").concat(pointerLength ? x : centerX + pointerWidth / 2, \", \").concat(pointerLength ? y : pointerEdge, \"\\n    L \").concat(centerX + pointerWidth / 2, \", \").concat(pointerEdge, \"\\n    L \").concat(rightEdge - cornerRadius, \", \").concat(pointerEdge, \"\\n    A \").concat(arc, \" \").concat(rightEdge, \", \").concat(pointerEdge - sign * cornerRadius, \"\\n    L \").concat(rightEdge, \", \").concat(oppositeEdge + sign * cornerRadius, \"\\n    A \").concat(arc, \" \").concat(rightEdge - cornerRadius, \", \").concat(oppositeEdge, \"\\n    L \").concat(leftEdge + cornerRadius, \", \").concat(oppositeEdge, \"\\n    A \").concat(arc, \" \").concat(leftEdge, \", \").concat(oppositeEdge + sign * cornerRadius, \"\\n    L \").concat(leftEdge, \", \").concat(pointerEdge - sign * cornerRadius, \"\\n    A \").concat(arc, \" \").concat(leftEdge + cornerRadius, \", \").concat(pointerEdge, \"\\n    z\");\n};\n\nvar getHorizontalPath = function getHorizontalPath(props) {\n  var pointerWidth = props.pointerWidth,\n      cornerRadius = props.cornerRadius,\n      orientation = props.orientation,\n      width = props.width,\n      height = props.height,\n      center = props.center;\n  var sign = orientation === 'left' ? 1 : -1; // const x = props.x + (props.dx || 0);\n  // const y = props.y + (props.dy || 0);\n\n  var centerX = isPlainObject(center) && center.x;\n  var centerY = isPlainObject(center) && center.y;\n  var pointerEdge = centerX - sign * (width / 2);\n  var oppositeEdge = centerX + sign * (width / 2);\n  var bottomEdge = centerY + height / 2;\n  var topEdge = centerY - height / 2; // This has been overridden so the pointer does not stick to data points -- want pointerLength to take precedence\n\n  var x = orientation === 'left' ? pointerEdge - props.pointerLength + (props.dx || 0) : pointerEdge + props.pointerLength + (props.dx || 0);\n  var y = center.y + (props.dy || 0);\n  var pointerLength = sign * (x - pointerEdge) > 0 ? 0 : props.pointerLength;\n  var direction = orientation === 'left' ? '0 0 0' : '0 0 1';\n  var arc = \"\".concat(cornerRadius, \" \").concat(cornerRadius, \" \").concat(direction);\n  return \"M \".concat(pointerEdge, \", \").concat(centerY - pointerWidth / 2, \"\\n    L \").concat(pointerLength ? x : pointerEdge, \", \").concat(pointerLength ? y : centerY + pointerWidth / 2, \"\\n    L \").concat(pointerEdge, \", \").concat(centerY + pointerWidth / 2, \"\\n    L \").concat(pointerEdge, \", \").concat(bottomEdge - cornerRadius, \"\\n    A \").concat(arc, \" \").concat(pointerEdge + sign * cornerRadius, \", \").concat(bottomEdge, \"\\n    L \").concat(oppositeEdge - sign * cornerRadius, \", \").concat(bottomEdge, \"\\n    A \").concat(arc, \" \").concat(oppositeEdge, \", \").concat(bottomEdge - cornerRadius, \"\\n    L \").concat(oppositeEdge, \", \").concat(topEdge + cornerRadius, \"\\n    A \").concat(arc, \" \").concat(oppositeEdge - sign * cornerRadius, \", \").concat(topEdge, \"\\n    L \").concat(pointerEdge + sign * cornerRadius, \", \").concat(topEdge, \"\\n    A \").concat(arc, \" \").concat(pointerEdge, \", \").concat(topEdge + cornerRadius, \"\\n    z\");\n};\n\nvar getFlyoutPath = function getFlyoutPath(props) {\n  var orientation = props.orientation || 'top';\n  return orientation === 'left' || orientation === 'right' ? getHorizontalPath(props) : getVerticalPath(props);\n};\n\nvar evaluateProps = function evaluateProps(props) {\n  /**\n   * Potential evaluated props are:\n   * `id`\n   * `style`\n   */\n  var id = Helpers.evaluateProp(props.id, props);\n  var style = Helpers.evaluateStyle(props.style, props);\n  return Object.assign({}, props, {\n    id: id,\n    style: style\n  });\n};\n\nvar ChartCursorFlyout = function ChartCursorFlyout(props) {\n  props = evaluateProps(props);\n  return React.cloneElement(props.pathComponent, Object.assign(Object.assign({}, props.events), {\n    style: props.style,\n    d: getFlyoutPath(props),\n    className: props.className,\n    shapeRendering: props.shapeRendering,\n    role: props.role,\n    transform: props.transform,\n    clipPath: props.clipPath\n  }));\n};\n\nChartCursorFlyout.propTypes = Object.assign(Object.assign({}, CommonProps.primitiveProps), {\n  center: PropTypes.shape({\n    x: PropTypes.number,\n    y: PropTypes.number\n  }),\n  cornerRadius: PropTypes.number,\n  datum: PropTypes.object,\n  dx: PropTypes.number,\n  dy: PropTypes.number,\n  height: PropTypes.number,\n  orientation: PropTypes.oneOf(['top', 'bottom', 'left', 'right']),\n  pathComponent: PropTypes.element,\n  pointerLength: PropTypes.number,\n  pointerWidth: PropTypes.number,\n  width: PropTypes.number,\n  x: PropTypes.number,\n  y: PropTypes.number\n});\nChartCursorFlyout.defaultProps = {\n  pathComponent: React.createElement(Path, null),\n  role: 'presentation',\n  shapeRendering: 'auto'\n};\nexport { ChartCursorFlyout };","map":{"version":3,"sources":["../../../../src/components/ChartCursorTooltip/ChartCursorFlyout.tsx"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["import * as React from 'react';\nimport PropTypes from 'prop-types';\nimport { Helpers, CommonProps, Path } from 'victory-core';\nimport isPlainObject from 'lodash/isPlainObject';\nconst getVerticalPath = (props) => {\n    const { pointerWidth, cornerRadius, orientation, width, height, center } = props;\n    const sign = orientation === 'bottom' ? 1 : -1;\n    // const x = props.x + (props.dx || 0);\n    // const y = props.y + (props.dy || 0);\n    const centerX = isPlainObject(center) && center.x;\n    const centerY = isPlainObject(center) && center.y;\n    const pointerEdge = centerY + sign * (height / 2);\n    const oppositeEdge = centerY - sign * (height / 2);\n    const rightEdge = centerX + width / 2;\n    const leftEdge = centerX - width / 2;\n    // This has been overridden so the pointer does not stick to data points -- want pointerLength to take precedence\n    const x = center.x + (props.dx || 0);\n    const y = orientation === 'bottom'\n        ? pointerEdge + props.pointerLength + (props.dy || 0)\n        : pointerEdge - props.pointerLength + (props.dy || 0);\n    const pointerLength = sign * (y - pointerEdge) < 0 ? 0 : props.pointerLength;\n    const direction = orientation === 'bottom' ? '0 0 0' : '0 0 1';\n    const arc = `${cornerRadius} ${cornerRadius} ${direction}`;\n    return `M ${centerX - pointerWidth / 2}, ${pointerEdge}\n    L ${pointerLength ? x : centerX + pointerWidth / 2}, ${pointerLength ? y : pointerEdge}\n    L ${centerX + pointerWidth / 2}, ${pointerEdge}\n    L ${rightEdge - cornerRadius}, ${pointerEdge}\n    A ${arc} ${rightEdge}, ${pointerEdge - sign * cornerRadius}\n    L ${rightEdge}, ${oppositeEdge + sign * cornerRadius}\n    A ${arc} ${rightEdge - cornerRadius}, ${oppositeEdge}\n    L ${leftEdge + cornerRadius}, ${oppositeEdge}\n    A ${arc} ${leftEdge}, ${oppositeEdge + sign * cornerRadius}\n    L ${leftEdge}, ${pointerEdge - sign * cornerRadius}\n    A ${arc} ${leftEdge + cornerRadius}, ${pointerEdge}\n    z`;\n};\nconst getHorizontalPath = (props) => {\n    const { pointerWidth, cornerRadius, orientation, width, height, center } = props;\n    const sign = orientation === 'left' ? 1 : -1;\n    // const x = props.x + (props.dx || 0);\n    // const y = props.y + (props.dy || 0);\n    const centerX = isPlainObject(center) && center.x;\n    const centerY = isPlainObject(center) && center.y;\n    const pointerEdge = centerX - sign * (width / 2);\n    const oppositeEdge = centerX + sign * (width / 2);\n    const bottomEdge = centerY + height / 2;\n    const topEdge = centerY - height / 2;\n    // This has been overridden so the pointer does not stick to data points -- want pointerLength to take precedence\n    const x = orientation === 'left'\n        ? pointerEdge - props.pointerLength + (props.dx || 0)\n        : pointerEdge + props.pointerLength + (props.dx || 0);\n    const y = center.y + (props.dy || 0);\n    const pointerLength = sign * (x - pointerEdge) > 0 ? 0 : props.pointerLength;\n    const direction = orientation === 'left' ? '0 0 0' : '0 0 1';\n    const arc = `${cornerRadius} ${cornerRadius} ${direction}`;\n    return `M ${pointerEdge}, ${centerY - pointerWidth / 2}\n    L ${pointerLength ? x : pointerEdge}, ${pointerLength ? y : centerY + pointerWidth / 2}\n    L ${pointerEdge}, ${centerY + pointerWidth / 2}\n    L ${pointerEdge}, ${bottomEdge - cornerRadius}\n    A ${arc} ${pointerEdge + sign * cornerRadius}, ${bottomEdge}\n    L ${oppositeEdge - sign * cornerRadius}, ${bottomEdge}\n    A ${arc} ${oppositeEdge}, ${bottomEdge - cornerRadius}\n    L ${oppositeEdge}, ${topEdge + cornerRadius}\n    A ${arc} ${oppositeEdge - sign * cornerRadius}, ${topEdge}\n    L ${pointerEdge + sign * cornerRadius}, ${topEdge}\n    A ${arc} ${pointerEdge}, ${topEdge + cornerRadius}\n    z`;\n};\nconst getFlyoutPath = (props) => {\n    const orientation = props.orientation || 'top';\n    return orientation === 'left' || orientation === 'right' ? getHorizontalPath(props) : getVerticalPath(props);\n};\nconst evaluateProps = (props) => {\n    /**\n     * Potential evaluated props are:\n     * `id`\n     * `style`\n     */\n    const id = Helpers.evaluateProp(props.id, props);\n    const style = Helpers.evaluateStyle(props.style, props);\n    return Object.assign({}, props, { id, style });\n};\nconst ChartCursorFlyout = (props) => {\n    props = evaluateProps(props);\n    return React.cloneElement(props.pathComponent, Object.assign(Object.assign({}, props.events), { style: props.style, d: getFlyoutPath(props), className: props.className, shapeRendering: props.shapeRendering, role: props.role, transform: props.transform, clipPath: props.clipPath }));\n};\nChartCursorFlyout.propTypes = Object.assign(Object.assign({}, CommonProps.primitiveProps), { center: PropTypes.shape({ x: PropTypes.number, y: PropTypes.number }), cornerRadius: PropTypes.number, datum: PropTypes.object, dx: PropTypes.number, dy: PropTypes.number, height: PropTypes.number, orientation: PropTypes.oneOf(['top', 'bottom', 'left', 'right']), pathComponent: PropTypes.element, pointerLength: PropTypes.number, pointerWidth: PropTypes.number, width: PropTypes.number, x: PropTypes.number, y: PropTypes.number });\nChartCursorFlyout.defaultProps = {\n    pathComponent: React.createElement(Path, null),\n    role: 'presentation',\n    shapeRendering: 'auto'\n};\nexport { ChartCursorFlyout };\n//# sourceMappingURL=ChartCursorFlyout.js.map"]},"metadata":{},"sourceType":"module"}